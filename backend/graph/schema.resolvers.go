package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"

	"github.com/Tattsum/enjo/backend/graph/generated"
	"github.com/Tattsum/enjo/backend/graph/model"
	"github.com/Tattsum/enjo/backend/twitter"
)

// GenerateInflammatoryText is the resolver for the generateInflammatoryText field.
func (r *mutationResolver) GenerateInflammatoryText(ctx context.Context, input model.GenerateInput) (*model.GenerateResult, error) {
	// Validate input
	if input.Level < 1 || input.Level > 5 {
		return nil, fmt.Errorf("level must be between 1 and 5, got %d", input.Level)
	}

	// Generate inflammatory text
	inflammatoryText, err := r.geminiClient.GenerateInflammatoryText(ctx, input.OriginalText, input.Level)
	if err != nil {
		return nil, fmt.Errorf("failed to generate inflammatory text: %w", err)
	}

	// Generate explanation
	explanation, err := r.geminiClient.GenerateExplanation(ctx, input.OriginalText, inflammatoryText)
	if err != nil {
		return nil, fmt.Errorf("failed to generate explanation: %w", err)
	}

	return &model.GenerateResult{
		InflammatoryText: inflammatoryText,
		Explanation:      &explanation,
	}, nil
}

// GenerateReplies is the resolver for the generateReplies field.
func (r *mutationResolver) GenerateReplies(ctx context.Context, text string) ([]*model.Reply, error) {
	// Validate input
	if text == "" {
		return nil, fmt.Errorf("text is required")
	}

	// Define reply types to generate
	replyTypes := []struct {
		Type        model.ReplyType
		Description string
	}{
		{model.ReplyTypeLogicalCriticism, "正論で批判するタイプ"},
		{model.ReplyTypeNitpicking, "揚げ足を取るタイプ"},
		{model.ReplyTypeOffTarget, "的外れな批判"},
		{model.ReplyTypeExcessiveDefense, "過剰に擁護するタイプ"},
	}

	// Generate replies for each type
	replies := make([]*model.Reply, 0, len(replyTypes))
	for i, rt := range replyTypes {
		content, err := r.geminiClient.GenerateReply(ctx, text, rt.Description)
		if err != nil {
			return nil, fmt.Errorf("failed to generate reply for type %s: %w", rt.Type, err)
		}

		replies = append(replies, &model.Reply{
			ID:      fmt.Sprintf("%d", i+1),
			Type:    rt.Type,
			Content: content,
		})
	}

	return replies, nil
}

// PostToTwitter is the resolver for the postToTwitter field.
func (r *mutationResolver) PostToTwitter(ctx context.Context, input model.TwitterPostInput) (*model.TwitterPostResult, error) {
	// Check if Twitter client is configured
	if r.twitterClient == nil {
		return &model.TwitterPostResult{
			Success:      false,
			ErrorMessage: stringPtr("Twitter API が設定されていません。環境変数を確認してください。"),
		}, nil
	}

	// Validate input
	if input.Text == "" {
		return &model.TwitterPostResult{
			Success:      false,
			ErrorMessage: stringPtr("投稿内容が空です"),
		}, nil
	}

	// Check character limit (considering runes for proper Unicode counting)
	if len([]rune(input.Text)) > 280 {
		return &model.TwitterPostResult{
			Success:      false,
			ErrorMessage: stringPtr("投稿内容が280文字を超えています"),
		}, nil
	}

	// Build tweet options
	var options []twitter.TweetOption
	if input.AddHashtag != nil && *input.AddHashtag {
		options = append(options, twitter.WithHashtag())
	}
	if input.AddDisclaimer != nil && *input.AddDisclaimer {
		options = append(options, twitter.WithDisclaimer())
	}

	// Post to Twitter
	result, err := r.twitterClient.PostTweet(ctx, input.Text, options...)
	if err != nil {
		return &model.TwitterPostResult{
			Success:      false,
			ErrorMessage: stringPtr(err.Error()),
		}, nil
	}

	return &model.TwitterPostResult{
		Success:  true,
		TweetID:  &result.ID,
		TweetURL: &result.URL,
	}, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "OK", nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
